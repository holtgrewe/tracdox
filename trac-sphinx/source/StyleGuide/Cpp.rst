.. _style-guide-cpp:

SeqAn C++ Code Style
--------------------

TOC()

The aim of this style guide is to enforce a certain level of
canonicality on all SeqAn code. Besides good comments, having a common
style guide is the key to being able to understand and change code
written by others easily.

(The style guide partially follows the `Google C++ Code Style
Guide <http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml>`_.)

C++ Features
~~~~~~~~~~~~

Reference Arguments
^^^^^^^^^^^^^^^^^^^

We prefer reference arguments over pointer arguments. Use ``const``
where possible.

+-------------+
| , !) ====   |
+=============+
+-------------+

::

    #FoldOut
    {|
    !</tt>, and <tt>!</tt> instead of <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>.
    |}

    ----
    While available from C++98, MSVC does not support them out of the box, a special header <tt><iso646.h></tt> has to be included.
    Also, they are unfamiliar to most C++ programmers and nothing in SeqAn is using them.

Default Arguments
^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Default arguments to global functions are problematic with generated forwards.
    They can be replaced with function overloading, so do not use them.
    ----
    You can replace default arguments with function overloading as follows.
    Do not do this.

    <pre>
    #cpp
    inline double f(int x, double y = 1.0)
    {
        // ...
    }

Do this instead.

::

    #cpp
    inline double f(int x, double y)
    {
        // ...
    }

    inline double f(int x)
    {
        return f(x, 1.0);
    }

.. raw:: html

   </pre>

Exceptions
^^^^^^^^^^

::

    #FoldOut
    Currently, the SeqAn code does not use any exceptions and is not exception safe.
    Do not use any exceptions yourself, instead use return codes.
    ----
    The following is an example where two chars are read using <tt><cstdio></tt> I/O.
    We use a return code of <tt>0</tt> to indicate no errors.

    <pre>
    #cpp
    int readSome(char & c, FILE * fp)
    {
        int res = fgetc(fp);
        if (res < 0)
            return res;
        res = fgetc(fp);
        if (res < 0)
            return res;
        c = res;
        return 0;
    }

.. raw:: html

   </pre>

Virtual Member Functions
^^^^^^^^^^^^^^^^^^^^^^^^

Do not use virtual member functions: Since we mostly use template
subclassing instead of C++ built-in subclassing, there rarely is the
need for member functions. In the case where there are member functions,
they should not be ``virtual`` since this is slow when used in tight
loops.

``static_cast<>``
^^^^^^^^^^^^^^^^^

Prefer ``static_cast<>`` over C-style casts.

``const_cast<>``
^^^^^^^^^^^^^^^^

::

    #FoldOut
    Use const-casts only to make an object const, do not remove consts.SANDBOX_ARG_PARSE
    Rather, use the <tt>mutable</tt> keyword on selected members.
    <tt>const_cast<></tt> is allowed for interfacing with external (C) APIs where the <tt>const</tt> keyword is missing but which do not modify the variable.
    ----
    The following is an example where <tt>const_cast<></tt> is OK:

    <pre>
    #cpp
    template <typename T>
    bool isXyz(T const & x)
    {
        return x._member == 0;
    }

    template <typename T>
    bool isXyz(T & x)
    {
        return const_cast<T const &>(x)._member == 0;
    }

.. raw:: html

   </pre>

``reinterpret_cast<>``
^^^^^^^^^^^^^^^^^^^^^^

Only use ``reinterpret_cast<>`` when you absolutely have to and you know
what you are doing! Sometimes, it is useful for very low-level code but
mostly it indicates a design flaw.

pre/post increment/decrement
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Prefer the "pre" variants for decrement and increment, especially in loops.
    Their advantage is that no copy of an object has to be made.
    ----
    Good:

    <pre>
    #cpp
    typedef Iterator<TContainer>::Type TIterator;
    for (TIterator it = begin(container); atEnd(it); ++it)
    {
        // do work
    }

Bad:

::

    #cpp
    typedef Iterator<TContainer>::Type TIterator;
    for (TIterator it = begin(container); atEnd(it); it++)
    {
        // do work
    }

.. raw:: html

   </pre>

Code Quality
~~~~~~~~~~~~

Const-Correctness
^^^^^^^^^^^^^^^^^

Write const correct code.
Read the `C++ FAQ const correctness article <http://www.parashift.com/c ++-faq-lite/const-correctness.html>`_ for more information.
Besides other things, this allows to use temporary objects without copying in functions that do not need to change their arguments.

Compiler Warnings
^^^^^^^^^^^^^^^^^

::

    #FoldOut
    All code in the ''core'' and ''extras'' repository must compile without any warnings using the flags generated by the CMake system.
    ----
    Currently, the GCC flags are:

    <pre>
    -W -Wall -Wstrict-aliasing -pedantic -Wno-long-long -Wno-variadic-macros

.. raw:: html

   </pre>

Style Conformance
^^^^^^^^^^^^^^^^^

Follow this code style whenever possible. However, prefer consistency
over conformance.

If you are editing code that is non-conforming consider whether you
could/should adapt the whole file to the new style. If this is not
feasible, prefer consistency over conformance.

Semantics
~~~~~~~~~

Parameter Ordering
^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    The general parameter order should be (1) output, (2) non-const input (e.g. file handles), (3) input, (4) tags.
    Within these groups, the order should be from mandatory to optional.
    ----
    In SeqAn, we read functions <tt>f(out1, out2, out3, ..., in1, in2, in3, ...)</tt> as <tt>(out1, out2, out3, ...) <- f(in1, in2, in3, ...)</tt>.

    E.g. <tt>assign()</tt>:

    <pre>
    #cpp
    template <typename T>
    void f(T & out, T const & in)
    {
        out = in;
    }

.. raw:: html

   </pre>

Scoping, Helper Code
~~~~~~~~~~~~~~~~~~~~

Global Variables
^^^^^^^^^^^^^^^^

Do not use global variables. They introduce hard-to find bugs and
require the introduction of a link-time library.

Tags In Function Arguments
^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Tags in function arguments should always be const.
    ----
    <pre>
    #cpp
    // somewhere in your code:

    struct Move_;
    typedef Tag<Move_> Move;

    // then, later:

    void appendValue(TContainer, Move const &)
    {
        // ...
    }

.. raw:: html

   </pre>

Structs and Classes
~~~~~~~~~~~~~~~~~~~

Visibility Specifiers
^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Visibility specifiers should go on the same indentation level as the <tt>class</tt> keyword.
    ----
    Example:

    <pre>
    #cpp
    class MyStruct
    {
    public:
    protected:
    private:
    };

.. raw:: html

   </pre>

Tag Definitions
^^^^^^^^^^^^^^^

::

    #FoldOut
    Tags that are possibly also used in other modules must not have additional parameters and be defined using the <tt>Tag<></tt> template.
    Tags that have parameters must only be used within the module they are defined in and have non-generic names.
    ----
    Tags defined with the <tt>Tag<></tt> template and a typedef can be defined multiply.
    These definitions must have the following pattern:

    <pre>
    #cpp
    struct TagName_;
    typedef Tag<TagName_> TagName;

This way, there can be multiple definitions of the same tag since the
struct ``TagName_`` is only declared but not defined and there can be
duplicate typedefs.

For tags (also those used for specialization) that have template
parameters, the case is different. Here, we cannot wrap them inside the
``Tag<>`` template with a typedef since it still depends on parameters.
Also we want to be able to instantiate tags so we can pass them as
function arguments. Thus, we have to add a struct body and thus define
the struct. There cannot be multiple identical definitions in C++. Thus,
each tag with parameters must have a unique name throughout SeqAn.
Possibly too generic names should be avoided. E.g. ``Chained`` should be
reserved as the name for a global tag but ``ChainedFile<>`` can be used
as a specialization tag in a file-related module.

Note that this restriction does not apply for internally used tags (e.g.
those that have an underscore postfix) since these can be renamed
without breaking the public API.

.. raw:: html

   </pre>

In-Place Member Functions
^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Whenever possible, functions should be declared and defined outside the class.
    The constructor, destructor and few operators have to be defined inside the class, however.
    ----
    The following has to be defined and declared within the class (also see [http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B Wikipedia]):

    *constructors
    *destructors
    *function call operator <tt>operator()</tt>
    *type cast operator <tt>operator T()</tt>
    *array subscript operator <tt>operator[]()</tt>
    *dereference-and-access-member operator <tt>operator->()</tt>
    *assignment operator <tt>operator=()</tt>

Formatting
~~~~~~~~~~

Constructor Initialization Lists
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    If the whole function prototype fits in one line, keep it in one line.
    Otherwise, wrap line after column and put each argument on its own line indented by one level.
    Align the initialization list.
    ----
    Example:

    <pre>
    #cpp
    class Class
    {
        MyClass() :
            member1(0),
            member2(1),
            member3(3)
        {}
    };

.. raw:: html

   </pre>

Line Length
^^^^^^^^^^^

The maximum line length is 120. Use a line length of 80 for header
comments and the code section separators.

Non-ASCII Characters
^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    All files should be UTF-8, non-ASCII characters should not occur in them nevertheless.
    ----
    In comments, use <tt>ss</tt> instead of <tt>ß</tt> and <tt>ae</tt> instead of <tt>ä</tt> etc.

    In strings, use UTF-8 coding. For example, <tt>"\xEF\xBB\xBF"</tt> is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.

Spaces VS Tabs
^^^^^^^^^^^^^^

::

    #FoldOut
    Do not use tabs, use spaces.
    Use <tt>"\t"</tt> in strings instead of plain tabs.
    ----
    After some discussion, we settled on this.
    All programmer's editors can be configured to use spaces instead of tabs.
    We use a four spaces to a tab.

    There can be problems when indenting in for loops with tabs, for example.
    Consider the following (<tt>-->|</tt> is a tab, <tt>_</tt> is a space):

    <pre>
    #cpp
    for (int i = 0, j = 0, k = 0, ...;
    <u>_</u>cond1 && cond2 &&; ++i)
    {
      // ...
    }

Here, indentation can happen up to match the previous line. Mixing tabs
and spaces works, too. However, since tabs are not shown in the editor,
people might indent a file with mixed tabs and spaces with spaces if
they are free to mix tabs and spaces.

::

    #cpp
    for (int i = 0, j = 0, k = 0, ...;
    -->|_cond1 && cond2 &&; ++i)
    {
      // ...
    }

.. raw:: html

   </pre>

Indentation
^^^^^^^^^^^

We use an indentation of four spaces per level.

::

    #FoldOut
    Note that '''namespaces do not cause an increase in indentation level.'''
    ----
    <pre>#cpp
    namespace seqan {

    class SomeClass
    {
    };

    }  // namespace seqan

.. raw:: html

   </pre>

Trailing Whitespace
^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Trailing whitespace is forbidden.
    ----
    Trailing whitespace is not visible, leading whitespace for indentation is perceptible through the text following it.
    Anything that cannot be seen can lead to "trash changes" in the SVN when somebody accidently removes it.

Inline Comments
^^^^^^^^^^^^^^^

::

    #FoldOut
    Use inline comments to document variables.
    ----
    Possibly align inline comments.

    <pre>
    #cpp
    short x;    // a short is enough!
    int myVar;  // this is my variable, do not touch it

.. raw:: html

   </pre>

Brace Positions
^^^^^^^^^^^^^^^

::

    #FoldOut
    Always put brace positions on the next line.
    ----
    <pre>
    #cpp
    class MyClass
    {
    public:
        int x;

        MyClass() : x(10)
        {}
    };

    void foo(char c)
    {
        switch (c)
        {
        case 'X':
            break;
        }
        // ...
    }

.. raw:: html

   </pre>

Conditionals
^^^^^^^^^^^^

::

    #FoldOut
    Use no spaces inside the parantheses, the <tt>else</tt> keyword belongs on a new line, use block braces consistently.
    ----
    Conditional statements should look like this:

    <pre>
    #cpp
    if (a == b)
    {
        return 0;
    }
    else if (c == d)
    {
        int x = a + b + d;
        return x;
    }

    if (a == b)
        return 0;
    else if (c == d)
        return a + b + d;

Do not leave out the spaces before and after the parantheses, do not put
leading or trailing space in the paranthesis. The following is wrong:

::

    #cpp
    if (foo){
        return 0;
    }
    if(foo)
        return 0;
    if (foo )
        return 0;

Make sure to add braces to all blocks if any block has one. The
following is wrong:

::

    #cpp
    if (a == b)
        return 0;
    else if (c == d)
    {
        int x = a + b + d;
        return x;
    }

.. raw:: html

   </pre>

Loops and Switch Statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Switch statements may use braces for blocks.
    Empty loop bodies should use <tt>{}</tt> or <tt>continue</tt>.
    ----
    Format your switch statements as follows.
    The usage of blocks is optional.
    Blocks can be useful for declaring variables inside the switch statement.

    <pre>
    #cpp
    switch (var)
    {
    case 0:
        return 1;
    case 1:
        return 0;
    default:
        SEQAN_FAIL("Invalid value!");
    }

    switch (var2)
    {
    case 0:
        return 1;
    case 1:
    {
        int x = 0;
        for (int i = 0; i < var3; ++i)
            x ++ i;
        return x;
    }
    default:
        SEQAN_FAIL("Invalid value!");
    }

Empty loop bodies should use ``{}`` or ``continue``, but not a single
semicolon.

::

    #cpp
    while (condition)
    {
      // Repeat test until it returns false.
    }

    for (int i = 0; i < kSomeNumber; ++i)
        {}  // Good - empty body.
    while (condition)
        continue;  // Good - continue indicates no logic.

.. raw:: html

   </pre>

Expressions
^^^^^^^^^^^

::

    #FoldOut
    Binary expressions are surrounded by one space. Unary expressions are preceded by one space.
    ----
    Example:

    <pre>
    #cpp
    {|
    ! c == d
    ! e == f
    ! x)
    |}

    {
        // ...
    }

    bool y = x;
    unsigned i = ~j;

.. raw:: html

   </pre>

Type Expressions
^^^^^^^^^^^^^^^^

::

    #FoldOut
    No spaces around period or arrow.
    Add spaces before and after pointer and references.
    <tt>const</tt> comes after the type.
    ----
    The following are good examples:

    <pre>
    #cpp
    int x = 0;
    int * ptr = x;                     // OK, spaces are good.
    int const & ref = x;               // OK, const after int
    int main(int argc, char ** argv);  // OK, group pointers.

Bad Examples:

::

    #cpp
    int x = 0;
    int* ptr = x;         // bad spaces
    int *ptr = x;         // bad spaces
    const int & ref = x;  // wrong placement of const
    int x = ptr -> z;     // bad spaces
    int x = obj. z;       // bad spaces

.. raw:: html

   </pre>

Function Return Types
^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    If a function definition is short, everything is on the same line. Otherwise, split.
    ----
    Good example:

    <pre>
    #cpp
    int foo();

    template <typename TString>
    typename Value<TString>::Type
    anotherFunction(TString const & foo, TString const & bar, /*...*/)
    {
        // ...
    }

.. raw:: html

   </pre>

Inline Functions
^^^^^^^^^^^^^^^^

::

    #FoldOut
    If a function definition is short, everything is on the same line. Otherwise put inline and return type in the same line.
    ----
    Good example:

    <pre>
    #cpp
    inline int foo();

    template <typename TString>
    inline typename Value<TString>::Type
    anotherFunction(TString const & foo, TString const & bar, /*...*/)
    {
        // ...
    }

.. raw:: html

   </pre>

Function Argument Lists
^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    If it fits in one line, keep in one line.
    Otherwise, wrap at the paranthesis, put each argument on its own line.
    For very long function names and parameter lines, break after opening bracket.
    ----
    Good example:

    <pre>
    #cpp
    template <typename TA, typename TB>
    inline void foo(TA & a, TB & b);

    template </*...*/>
    inline void foo2(TA & a,
                     TB & b,
                     ...
                     TY & y,
                     TZ & z);

    template </*...*/>
    inline void _functionThisIsAVeryVeryLongFunctionNameSinceItsAHelper(
        TThisTypeWasMadeToForceYouToWrapInTheLongNameMode & a,
        TB & b,
        TC & c,
        TB & d,
        ...);

.. raw:: html

   </pre>

Template Argument Lists
^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Follow conventions of function parameter lists, no blank after opening <tt><</tt>.
    ----
    As for function parameters, try to fit everything on one line if possible, otherwise, break the template parameters over multiple lines and put the commas directly after the type names.
    <pre>
    #cpp
    template <typename T1, typename T1>
    void foo() {}

    template <typename T1, typename T2, ...
              typename T10, typename T11>
    void bar() {}

Multiple closing ``>`` go to the same line and are only separated by
spaces if two closing angular brackets come after each other.

::

    #cpp
    typedef Iterator<Value<TValue>::Type,
                     Standard> ::Type

    typedef String<char, Alloc<> > TMyString
    // -------------------------^

.. raw:: html

   </pre>

Function Calls
^^^^^^^^^^^^^^

::

    #FoldOut
    Similar rules as in [#FunctionArgumentLists Function Argument Lists] apply.
    When wrapped, not each parameter has to occur on its own line.
    ----
    Example:
    <pre>
    #cpp
    foo(a, b);

    foo2(a, b, c, ...
         x, y, z);

    if (x)
    {
        if (y)
        {
            _functionThisIsAVeryVeryLongFunctionNameSinceItsAHelper(
                firstParameterWithALongName, b, c, d);
        }
    }

.. raw:: html

   </pre>

Naming Rules
~~~~~~~~~~~~

In the following, camel case means that the first letter of each word is
written upper case, the remainder is written in lower case.
Abbreviations of length 2 are kept in upper case, longer abbreviations
are camel-cased.

Macros
^^^^^^

::

    #FoldOut
    Macros are all upper case, separated by underscores, prefixed with <tt>SEQAN_</tt>.
    ----
    Example:

    <pre>
    #cpp
    SEQAN_ASSERT_EQ(val1, val2);

    #define SEQAN_MY_TMP_MACRO(x) f(x)
    // ...
    SEQAN_MY_TMP_MACRO(1);
    // ...
    #undef SEQAN_MY_TMP_MACRO

.. raw:: html

   </pre>

Variable Naming
^^^^^^^^^^^^^^^

::

    #FoldOut
    Variables are named in camel case, starting with a lower-case parameter.
    Internal member variables have an underscore prefix.
    ----
    Example:

    <pre>
    #cpp
    int x;
    int myVar;
    int saValue(/*...*/);
    int getSAValue(/*...*/);

    struct FooBar
    {
        int _x;
    };

.. raw:: html

   </pre>

Constant / Enum Value Naming
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Constant and enum values are named like macros: All-upper case, separated by dashes.
    ----
    Example:

    <pre>
    #cpp
    enum MyEnum
    {
        MY_ENUM_VALUE1 = 1,
        MY_ENUM_VALUE2 = 20
    };

    int const MY_VAR = 10;

.. raw:: html

   </pre>

Struct / Enum / Class Naming
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Types are written in camel case, starting with an upper case character.
    ----
    Internal library types have an underscore suffix.

    Example:

    <pre>
    #cpp
    struct InternalType_
    {};

    struct SAValue
    {};

    struct LcpTable
    {};

.. raw:: html

   </pre>

Metafunction Naming
^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Metafunctions are named like structs, defined values are named <tt>VALUE</tt>, types <tt>Type</tt>.
    ----
    Metafunctions should not export any other types or values publically, e.g. they should have an underscore suffix.

    Example:

    <pre>
    #cpp
    template <typename T>
    struct MyMetaFunction
    {
        typedef typename RemoveConst<T>::Type TNoConst_;
        typedef TNonConst_ Type;
    };

    template <typename T>
    struct MyMetaFunction2
    {
        typedef True Type;
        static bool const VALUE = false;
    };

.. raw:: html

   </pre>

Function Naming
^^^^^^^^^^^^^^^

::

    #FoldOut
    The same naming rule as for variables applies.
    ----
    Example:

    <pre>
    #cpp
    void fooBar();

    template <typename T>
    int saValue(T & x);

    template <typename T>
    void lcpTable(T & x);

.. raw:: html

   </pre>

Names In Documentation
^^^^^^^^^^^^^^^^^^^^^^

In the documentation, classes have the same name as in the source code,
e.g. the class StringSet is documented as "class StringSet."
Specializations are named "``$SPEC $CLASS``\ ", e.g. "Concat StringSet",
"Horspool Finder."

Comments
~~~~~~~~

File Comments
^^^^^^^^^^^^^

::

    #FoldOut
    Each file should begin with a file header.
    ----
    The file header has the format.
    The ''skel.py'' tool automatically generates files with appropriate headers.

    <pre>
    #cpp
    // ==========================================================================
    //                              $PROJECT NAME
    // ==========================================================================
    // Copyright (C) 2010 $AUTHOR, $ORGANIZATION
    //
    // $LICENSE
    //
    // ==========================================================================
    // Author: $NAME <$EMAIL>
    // ==========================================================================
    // $FILE_DESCRIPTION
    // ==========================================================================

.. raw:: html

   </pre>

Class, Function, Metafunction, Enum, Macro DDDoc Comments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    Each public class, function, metafunction, enum, and macro should be documented using [[HowTo/DocumentCode| DDDoc]].
    Internal code should be documented, too.
    ----
    Example:

    <pre>
    #cpp
    /**
    .Class.IntervalAndCargo:
    ..cat:Miscellaneous
    ..summary:A simple record type that stores an interval and a cargo value.
    ..signature:IntervalAndCargo<TValue, TCargo>
    ..param.TValue:The value type, that is the type of the interval borders.
    ...default:int.
    ...metafunction:Metafunction.Value
    ..param.TCargo:The cargo type.
    ...default:int.
    ...metafunction:Metafunction.Cargo
    ..include:seqan/refinement.h
    */

    template <typename TValue = int, typename TCargo = int>
    class IntervalAndCargo
    {
    // ...
    };

    // This functions helps the XYZ class to fulfill the ABC functionality.
    //
    // It corresponds to function FUNC() in the paper describing the original
    // algorithm.  The variables in this function correspond to the names in the
    // paper and thus the code style is broken locally.

    void _helperFunction(/*...*/)
    {}

.. raw:: html

   </pre>

Implementation Comments
^^^^^^^^^^^^^^^^^^^^^^^

All functions etc. should be well-documented. In most cases, it is more
important how something is done instead of of what is done.

TODO Comments
^^^^^^^^^^^^^

TODO comments have the format ``// TODO($USERNAME): $TODO_COMMENT``. The
username is the username of the one writing the item, not the one to fix
it. Use tickets for this.

Source Tree Structure
~~~~~~~~~~~~~~~~~~~~~

File Name Rules
^^^^^^^^^^^^^^^

::

    #FoldOut
    File and directories are named all-lower case, words are separated by underscores.
    ----
    Exceptions are ''INFO'', ''COPYING'', ''README'', ... files.

    Examples:

    *''string_base.h''
    *''string_packed.h''
    *''suffix_array.h''
    *''lcp_table.h''

Overall Structure
^^^^^^^^^^^^^^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

Repositories
^^^^^^^^^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

Library Modules
^^^^^^^^^^^^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

Tests
^^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

Demos
^^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

Apps
^^^^

Can be found in wiki:WhitePapers/RepositoryStructure for now.

File Structure
~~~~~~~~~~~~~~

Header ``#define`` guard
^^^^^^^^^^^^^^^^^^^^^^^^

::

    #FoldOut
    The header <tt>#define</tt> include guards are constructed from full paths to the repository root.
    ----
    Example:

    {|
    ! '''filename'''
    ! '''preprocessor symbol'''
    |-
    |  seqan/core/include/seqan/basic/iterator_base.h
    |  <tt>SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_</tt>
    |}


    <pre>
    #cpp
    #ifndef SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_
    #define SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_
    #endif  // #ifndef SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_

.. raw:: html

   </pre>

Include Order
^^^^^^^^^^^^^

The include order should be (1) standard library requirements, (2)
external requirements, (3) required SeqAn modules.

In SeqAn module headers (e.g. *basic.h*), then all files in the module
are included.

CPP File Structure
^^^^^^^^^^^^^^^^^^

::

    #cpp
    // ==========================================================================
    //                                $APP_NAME
    // ==========================================================================
    // Copyright (c) 2006-2011, Knut Reinert, FU Berlin
    // All rights reserved.
    //
    // Redistribution and use in source and binary forms, with or without
    // modification, are permitted provided that the following conditions are met:
    //
    //     * Redistributions of source code must retain the above copyright
    //       notice, this list of conditions and the following disclaimer.
    //     * Redistributions in binary form must reproduce the above copyright
    //       notice, this list of conditions and the following disclaimer in the
    //       documentation and/or other materials provided with the distribution.
    //     * Neither the name of Knut Reinert or the FU Berlin nor the names of
    //       its contributors may be used to endorse or promote products derived
    //       from this software without specific prior written permission.
    //
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    // ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
    // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
    // DAMAGE.
    //
    // ==========================================================================
    // Author: $AUTHOR_NAME <$AUTHOR_EMAIL>
    // ==========================================================================
    // $FILE_COMMENT
    // ==========================================================================

    #include <seqan/basic.h>
    #include <seqan/sequence.h>

    #include <seqan/misc/misc_cmdparser.h>

    #include "app_name.h"

    using namespace seqan;

    // Program entry point
    int main(int argc, char const ** argv)
    {
        // ...
    }

Application Header Structure
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #cpp
    // ==========================================================================
    //                                $APP_NAME
    // ==========================================================================
    // Copyright (c) 2006-2010, Knut Reinert, FU Berlin
    // All rights reserved.
    //
    // Redistribution and use in source and binary forms, with or without
    // modification, are permitted provided that the following conditions are met:
    //
    //     * Redistributions of source code must retain the above copyright
    //       notice, this list of conditions and the following disclaimer.
    //     * Redistributions in binary form must reproduce the above copyright
    //       notice, this list of conditions and the following disclaimer in the
    //       documentation and/or other materials provided with the distribution.
    //     * Neither the name of Knut Reinert or the FU Berlin nor the names of
    //       its contributors may be used to endorse or promote products derived
    //       from this software without specific prior written permission.
    //
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    // ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
    // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
    // DAMAGE.
    //
    // ==========================================================================
    // Author: $AUTHOR_NAME <$AUTHOR_EMAIL>
    // ==========================================================================
    // $FILE_COMMENT
    // ==========================================================================

    #ifndef CORE_APPS_APP_NAME_HEADER_FILE_H_
    #define CORE_APPS_APP_NAME_HEADER_FILE_H_

    // ==========================================================================
    // Forwards
    // ==========================================================================

    // ==========================================================================
    // Tags, Classes, Enums
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Class ClassName
    // --------------------------------------------------------------------------

    // ==========================================================================
    // Metafunctions
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Metafunction MetafunctionName
    // --------------------------------------------------------------------------

    // ==========================================================================
    // Functions
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Function functionName()
    // --------------------------------------------------------------------------

    #endif  // CORE_APPS_APP_NAME_HEADER_FILE_H_

Library Header Structure
^^^^^^^^^^^^^^^^^^^^^^^^

::

    #cpp
    // ==========================================================================
    //                 SeqAn - The Library for Sequence Analysis
    // ==========================================================================
    // Copyright (c) 2006-2010, Knut Reinert, FU Berlin
    // All rights reserved.
    //
    // Redistribution and use in source and binary forms, with or without
    // modification, are permitted provided that the following conditions are met:
    //
    //     * Redistributions of source code must retain the above copyright
    //       notice, this list of conditions and the following disclaimer.
    //     * Redistributions in binary form must reproduce the above copyright
    //       notice, this list of conditions and the following disclaimer in the
    //       documentation and/or other materials provided with the distribution.
    //     * Neither the name of Knut Reinert or the FU Berlin nor the names of
    //       its contributors may be used to endorse or promote products derived
    //       from this software without specific prior written permission.
    //
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    // ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
    // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
    // DAMAGE.
    //
    // ==========================================================================
    // Author: AUTHOR NAME <AUTHOR EMAIL>
    // ==========================================================================
    // SHORT COMMENT ON WHAT THIS FILE CONTAINS
    // ==========================================================================

    #ifndef CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_
    #define CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_

    namespace seqan {

    // ==========================================================================
    // Forwards
    // ==========================================================================

    // ==========================================================================
    // Tags, Classes, Enums
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Class ClassName
    // --------------------------------------------------------------------------

    // ==========================================================================
    // Metafunctions
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Metafunction MetafunctionName
    // --------------------------------------------------------------------------

    // ==========================================================================
    // Functions
    // ==========================================================================

    // --------------------------------------------------------------------------
    // Function functionName()
    // --------------------------------------------------------------------------

    }  // namespace seqan

    #endif  // CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_

.. raw:: mediawiki

   {{TracNotice|{{PAGENAME}}}}
